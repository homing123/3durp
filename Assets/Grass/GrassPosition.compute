// Each #kernel tells which function to compile; you can have many kernels
#define ThreadMax 256
#define GroupMax 512
#include "Util.compute"
#pragma kernel GetPosition

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct GrassData
{
    float2 chunkUV;
    float3 position;
};

RWStructuredBuffer<GrassData> _GrassBuffer;
int _GrassAmount;
int _Scale;
float3 _Position;

[numthreads(ThreadMax,1,1)]
void GetPosition(uint t_idx : SV_GroupIndex, uint3 g_id : SV_GroupID)
{
    // TODO: insert actual code here!
    int AxisGrassCount = _Scale * _GrassAmount;
    uint curIdx = GetTotalIdx(t_idx, g_id, uint3(ThreadMax, 1, 1), GroupMax);
 
    if (curIdx >= uint(AxisGrassCount * AxisGrassCount))
    {
        return;
    }
    
    int grassIdxY = int(curIdx) / AxisGrassCount;
    int grassIdxX = int(curIdx) % AxisGrassCount;
    GrassData grass;
    float dis = AxisGrassCount == 1 ? 0 : (float)_Scale / (AxisGrassCount - 1);
    float2 minxz = _Position.xz - _Scale * 0.5f;
    minxz += float2(grassIdxX * dis, grassIdxY * dis);
    
    grass.position = float3(minxz.x, _Position.y, minxz.y);
    float duv = 1.0f / AxisGrassCount;
    grass.chunkUV = float2(duv * grassIdxX, duv * grassIdxY);
    _GrassBuffer[curIdx] = grass;
}
