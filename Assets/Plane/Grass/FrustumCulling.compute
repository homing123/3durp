// Each #kernel tells which function to compile; you can have many kernels
#define THREAD_MAX 512
#define GROUPX_MAX 512
#pragma kernel FrustumCull
#pragma kernel PrefixSum
#pragma kernel GroupPrefixSum
#pragma kernel SetDrawedGrass

#include "Util.compute"

struct GrassData
{
    float2 chunkuv;
    float3 position;
};


RWStructuredBuffer<GrassData> _GrassBuffers[25];


RWStructuredBuffer<GrassData> _GrassBuffer;
RWStructuredBuffer<uint> _DrawedBuffer;

uint _GrassCount;
float4x4 _MatVP;
float3 _CamPos;
float _RenderDis;



[numthreads(THREAD_MAX, 1, 1)]
void FrustumCull(uint t_idx : SV_GroupIndex, uint3 g_id : SV_GroupID)
{
    switch (_GrassCount)
    {
        case 1:
            break;
    }
    // TODO: insert actual code here!
    uint idx = t_idx + g_id.x * THREAD_MAX + g_id.y * THREAD_MAX * GROUPX_MAX;
    if(idx >= _GrassCount)
    {
        return;
    }
    float3 posWS = _GrassBuffer[idx].position;
    float4 posCS = mul(_MatVP, float4(posWS, 1));
    float3 posNDC;
    posNDC.xy = posCS.xy / -posCS.w;
    posNDC.z = -posCS.w;
    
    float dis = length(_CamPos - posWS);
    int isDrawed = posNDC.x > -1.2f && posNDC.x < 1.2f && posNDC.y > -1.2f && posNDC.y < 1.2f && posNDC.z > -0.2f;
    isDrawed &= dis < _RenderDis;
    isDrawed |= dis < 1.5f;
    _DrawedBuffer[idx] = isDrawed;
}

groupshared uint _prefixSumTemp[THREAD_MAX * 2];
RWStructuredBuffer<uint> _DrawedPrefixSumBuffer;
RWStructuredBuffer <uint> _DrawedGroupSumBuffer;

[numthreads(THREAD_MAX,1,1)]
void PrefixSum(uint t_idx : SV_GroupIndex, uint3 g_id : SV_GroupID)
{
    uint idx = t_idx + g_id.x * THREAD_MAX + g_id.y * THREAD_MAX * GROUPX_MAX;
    uint g_idx = g_id.y * GROUPX_MAX + g_id.x;

    _prefixSumTemp[t_idx] = idx >= _GrassCount ? 0 :  _DrawedBuffer[idx];

    int outputBegin = 0;
    int inputBegin = THREAD_MAX;
    GroupMemoryBarrierWithGroupSync();

    for (uint stride = 1; stride < THREAD_MAX; stride <<= 1)
    {
        _prefixSumTemp[inputBegin + t_idx] = t_idx < stride ? _prefixSumTemp[outputBegin + t_idx] : _prefixSumTemp[outputBegin + t_idx] + _prefixSumTemp[outputBegin + t_idx - stride];

        int temp = outputBegin;
        outputBegin = inputBegin;
        inputBegin = temp;

        GroupMemoryBarrierWithGroupSync();
    }

    if (idx < _GrassCount)
    {
        _DrawedPrefixSumBuffer[idx] = _prefixSumTemp[outputBegin + t_idx];
        if (t_idx == THREAD_MAX - 1 || idx == _GrassCount - 1)
        {
            _DrawedGroupSumBuffer[g_idx] = _DrawedPrefixSumBuffer[idx];
        }
    }


}

uint _GroupCount;
groupshared uint _prefixGroupSumTemp[GROUPX_MAX * 2];
RWStructuredBuffer <uint> _DrawedGroupPrefixSumBuffer;
RWStructuredBuffer<uint> _MeshArgsBuffer;

//this kernel funtion has only one group
[numthreads(GROUPX_MAX,1,1)]
void GroupPrefixSum(uint t_idx : SV_GroupIndex)
{
    _prefixGroupSumTemp[t_idx] = t_idx < _GroupCount ? _DrawedGroupSumBuffer[t_idx] : 0;
    int outBegin = 0;
    int inBegin = GROUPX_MAX;
    GroupMemoryBarrierWithGroupSync();

    for (uint stride = 1; stride < _GroupCount; stride <<= 1)
    {
        _prefixGroupSumTemp[inBegin + t_idx] = t_idx < stride ? _prefixGroupSumTemp[outBegin + t_idx] : _prefixGroupSumTemp[outBegin + t_idx] + _prefixGroupSumTemp[outBegin + t_idx - stride];
        int temp = outBegin;
        outBegin = inBegin;
        inBegin = temp;

        GroupMemoryBarrierWithGroupSync();
    }

    if (t_idx < _GroupCount)
    {
        _DrawedGroupPrefixSumBuffer[t_idx] = _prefixGroupSumTemp[outBegin + t_idx];
        if (t_idx == _GroupCount - 1)
        {
            _MeshArgsBuffer[1] = _prefixGroupSumTemp[outBegin + t_idx];
        }
    }
}

RWStructuredBuffer <GrassData> _DrawedGrassBuffer;

[numthreads(THREAD_MAX, 1, 1)]
void SetDrawedGrass(uint t_idx : SV_GroupIndex, uint3 g_id : SV_GroupID)
{
    uint idx = t_idx + g_id.x * THREAD_MAX + g_id.y * THREAD_MAX * GROUPX_MAX;
    uint g_idx = g_id.y * GROUPX_MAX + g_id.x;
    if (idx >= _GrassCount)
    {
        return;
    }

    uint groupOffset = g_idx == 0 ? 0 : _DrawedGroupPrefixSumBuffer[g_idx - 1];
    uint previousPrefixSum = t_idx == 0 ? 0 : _DrawedPrefixSumBuffer[idx - 1];
    uint curPrefixSum = _DrawedPrefixSumBuffer[idx];
    if (previousPrefixSum + 1 == curPrefixSum)
    {
        _DrawedGrassBuffer[previousPrefixSum + groupOffset] = _GrassBuffer[idx];
    }

}



